# ğŸ“˜ LeetCode Solutions in C++ and Java

Welcome to our collaborative LeetCode solutions repository! This project contains **150 curated coding problems** with solutions implemented in both **C++** and **Java**.

### ğŸ‘¥ Contributors:
- **Vedika** â€“ All solutions in **C++**
- **Tushar Kashyap** â€“ All solutions in **Java**
---

## ğŸ“‘ Problem Index


| No. | Question Name | C++ | Java |
|-----|---------------|-----|------|
| 1   | Contains Duplicate | [ğŸ”— C++](#contains-duplicate) | [ğŸ”— Java](#contains-duplicate) |
| 2   | Valid Anagram | [ğŸ”— C++](#valid-anagram) | [ğŸ”— Java](#valid-anagram) |
| 3   | Two Sum | [ğŸ”— C++](#two-sum) | [ğŸ”— Java](#two-sum) |
| 4   | Group Anagrams | [ğŸ”— C++](#group-anagrams) | [ğŸ”— Java](#group-anagrams) |
| 5   | Top K Frequent Elements | [ğŸ”— C++](#top-k-frequent-elements) | [ğŸ”— Java](#top-k-frequent-elements) |
| 6   | Product of Array Except Self | [ğŸ”— C++](#product-of-array-except-self) | [ğŸ”— Java](#product-of-array-except-self) |
| 7   | Valid Sudoku | [ğŸ”— C++](#valid-sudoku) | [ğŸ”— Java](#valid-sudoku) |
| 8   | Encode and Decode Strings | [ğŸ”— C++](#encode-and-decode-strings) | [ğŸ”— Java](#encode-and-decode-strings) |
| 9   | Longest Consecutive Sequence | [ğŸ”— C++](#longest-consecutive-sequence) | [ğŸ”— Java](#longest-consecutive-sequence) |
| 10  | Valid Palindrome | [ğŸ”— C++](#valid-palindrome) | [ğŸ”— Java](#valid-palindrome) |
| 11  | Two Sum II Input Array Is Sorted | [ğŸ”— C++](#two-sum-ii-input-array-is-sorted) | [ğŸ”— Java](#two-sum-ii-input-array-is-sorted) |
| 12  | 3Sum | [ğŸ”— C++](#3sum) | [ğŸ”— Java](#3sum) |
| 13  | Container With Most Water | [ğŸ”— C++](#container-with-most-water) | [ğŸ”— Java](#container-with-most-water) |
| 14  | Trapping Rain Water | [ğŸ”— C++](#trapping-rain-water) | [ğŸ”— Java](#trapping-rain-water) |
| 15  | Best Time to Buy And Sell Stock | [ğŸ”— C++](#best-time-to-buy-and-sell-stock) | [ğŸ”— Java](#best-time-to-buy-and-sell-stock) |
| 16  | Longest Substring Without Repeating Characters | [ğŸ”— C++](#longest-substring-without-repeating-characters) | [ğŸ”— Java](#longest-substring-without-repeating-characters) |
| 17  | Longest Repeating Character Replacement | [ğŸ”— C++](#longest-repeating-character-replacement) | [ğŸ”— Java](#longest-repeating-character-replacement) |
| 18  | Permutation In String | [ğŸ”— C++](#permutation-in-string) | [ğŸ”— Java](#permutation-in-string) |
| 19  | Minimum Window Substring | [ğŸ”— C++](#minimum-window-substring) | [ğŸ”— Java](#minimum-window-substring) |
| 20  | Sliding Window Maximum | [ğŸ”— C++](#sliding-window-maximum) | [ğŸ”— Java](#sliding-window-maximum) |
| 21  | Valid Parentheses | [ğŸ”— C++](#valid-parentheses) | [ğŸ”— Java](#valid-parentheses) |
| 22  | Min Stack | [ğŸ”— C++](#min-stack) | [ğŸ”— Java](#min-stack) |
| 23  | Evaluate Reverse Polish Notation | [ğŸ”— C++](#evaluate-reverse-polish-notation) | [ğŸ”— Java](#evaluate-reverse-polish-notation) |
| 24  | Generate Parentheses | [ğŸ”— C++](#generate-parentheses) | [ğŸ”— Java](#generate-parentheses) |
| 25  | Daily Temperatures | [ğŸ”— C++](#daily-temperatures) | [ğŸ”— Java](#daily-temperatures) |
| 26  | Car Fleet | [ğŸ”— C++](#car-fleet) | [ğŸ”— Java](#car-fleet) |
| 27  | Largest Rectangle In Histogram | [ğŸ”— C++](#largest-rectangle-in-histogram) | [ğŸ”— Java](#largest-rectangle-in-histogram) |
| 28  | Binary Search | [ğŸ”— C++](#binary-search) | [ğŸ”— Java](#binary-search) |
| 29  | Search a 2D Matrix | [ğŸ”— C++](#search-a-2d-matrix) | [ğŸ”— Java](#search-a-2d-matrix) |
| 30  | Koko Eating Bananas | [ğŸ”— C++](#koko-eating-bananas) | [ğŸ”— Java](#koko-eating-bananas) |
| 31  | Find Minimum In Rotated Sorted Array | [ğŸ”— C++](#find-minimum-in-rotated-sorted-array) | [ğŸ”— Java](#find-minimum-in-rotated-sorted-array) |
| 32  | Search In Rotated Sorted Array | [ğŸ”— C++](#search-in-rotated-sorted-array) | [ğŸ”— Java](#search-in-rotated-sorted-array) |
| 33  | Time Based Key Value Store | [ğŸ”— C++](#time-based-key-value-store) | [ğŸ”— Java](#time-based-key-value-store) |
| 34  | Median of Two Sorted Arrays | [ğŸ”— C++](#median-of-two-sorted-arrays) | [ğŸ”— Java](#median-of-two-sorted-arrays) |
| 35  | Reverse Linked List | [ğŸ”— C++](#reverse-linked-list) | [ğŸ”— Java](#reverse-linked-list) |
| 36  | Merge Two Sorted Lists | [ğŸ”— C++](#merge-two-sorted-lists) | [ğŸ”— Java](#merge-two-sorted-lists) |
| 37  | Reorder List | [ğŸ”— C++](#reorder-list) | [ğŸ”— Java](#reorder-list) |
| 38  | Remove Nth Node From End of List | [ğŸ”— C++](#remove-nth-node-from-end-of-list) | [ğŸ”— Java](#remove-nth-node-from-end-of-list) |
| 39  | Copy List With Random Pointer | [ğŸ”— C++](#copy-list-with-random-pointer) | [ğŸ”— Java](#copy-list-with-random-pointer) |
| 40  | Add Two Numbers | [ğŸ”— C++](#add-two-numbers) | [ğŸ”— Java](#add-two-numbers) |
| 41  | Linked List Cycle | [ğŸ”— C++](#linked-list-cycle) | [ğŸ”— Java](#linked-list-cycle) |
| 42  | Find The Duplicate Number | [ğŸ”— C++](#find-the-duplicate-number) | [ğŸ”— Java](#find-the-duplicate-number) |
| 43  | LRU Cache | [ğŸ”— C++](#lru-cache) | [ğŸ”— Java](#lru-cache) |
| 44  | Merge K Sorted Lists | [ğŸ”— C++](#merge-k-sorted-lists) | [ğŸ”— Java](#merge-k-sorted-lists) |
| 45  | Reverse Nodes In K Group | [ğŸ”— C++](#reverse-nodes-in-k-group) | [ğŸ”— Java](#reverse-nodes-in-k-group) |
| 46  | Invert Binary Tree | [ğŸ”— C++](#invert-binary-tree) | [ğŸ”— Java](#invert-binary-tree) |
| 47  | Maximum Depth of Binary Tree | [ğŸ”— C++](#maximum-depth-of-binary-tree) | [ğŸ”— Java](#maximum-depth-of-binary-tree) |
| 48  | Diameter of Binary Tree | [ğŸ”— C++](#diameter-of-binary-tree) | [ğŸ”— Java](#diameter-of-binary-tree) |
| 49  | Balanced Binary Tree | [ğŸ”— C++](#balanced-binary-tree) | [ğŸ”— Java](#balanced-binary-tree) |
| 50  | Same Tree | [ğŸ”— C++](#same-tree) | [ğŸ”— Java](#same-tree) |
| 51  | Subtree of Another Tree | [ğŸ”— C++](#subtree-of-another-tree) | [ğŸ”— Java](#subtree-of-another-tree) |
| 52  | Lowest Common Ancestor of a Binary Search Tree | [ğŸ”— C++](#lowest-common-ancestor-of-a-binary-search-tree) | [ğŸ”— Java](#lowest-common-ancestor-of-a-binary-search-tree) |
| 53  | Binary Tree Level Order Traversal | [ğŸ”— C++](#binary-tree-level-order-traversal) | [ğŸ”— Java](#binary-tree-level-order-traversal) |
| 54  | Binary Tree Right Side View | [ğŸ”— C++](#binary-tree-right-side-view) | [ğŸ”— Java](#binary-tree-right-side-view) |
| 55  | Count Good Nodes In Binary Tree | [ğŸ”— C++](#count-good-nodes-in-binary-tree) | [ğŸ”— Java](#count-good-nodes-in-binary-tree) |
| 56  | Validate Binary Search Tree | [ğŸ”— C++](#validate-binary-search-tree) | [ğŸ”— Java](#validate-binary-search-tree) |
| 57  | Kth Smallest Element In a Bst | [ğŸ”— C++](#kth-smallest-element-in-a-bst) | [ğŸ”— Java](#kth-smallest-element-in-a-bst) |
| 58  | Construct Binary Tree From Preorder And Inorder Traversal | [ğŸ”— C++](#construct-binary-tree-from-preorder-and-inorder-traversal) | [ğŸ”— Java](#construct-binary-tree-from-preorder-and-inorder-traversal) |
| 59  | Binary Tree Maximum Path Sum | [ğŸ”— C++](#binary-tree-maximum-path-sum) | [ğŸ”— Java](#binary-tree-maximum-path-sum) |
| 60  | Serialize And Deserialize Binary Tree | [ğŸ”— C++](#serialize-and-deserialize-binary-tree) | [ğŸ”— Java](#serialize-and-deserialize-binary-tree) |
| 61  | Implement Trie Prefix Tree | [ğŸ”— C++](#implement-trie-prefix-tree) | [ğŸ”— Java](#implement-trie-prefix-tree) |
| 62  | Design Add And Search Words Data Structure | [ğŸ”— C++](#design-add-and-search-words-data-structure) | [ğŸ”— Java](#design-add-and-search-words-data-structure) |
| 63  | Word Search II | [ğŸ”— C++](#word-search-ii) | [ğŸ”— Java](#word-search-ii) |
| 64  | Kth Largest Element In a Stream | [ğŸ”— C++](#kth-largest-element-in-a-stream) | [ğŸ”— Java](#kth-largest-element-in-a-stream) |
| 65  | Last Stone Weight | [ğŸ”— C++](#last-stone-weight) | [ğŸ”— Java](#last-stone-weight) |
| 66  | K Closest Points to Origin | [ğŸ”— C++](#k-closest-points-to-origin) | [ğŸ”— Java](#k-closest-points-to-origin) |
| 67  | Kth Largest Element In An Array | [ğŸ”— C++](#kth-largest-element-in-an-array) | [ğŸ”— Java](#kth-largest-element-in-an-array) |
| 68  | Task Scheduler | [ğŸ”— C++](#task-scheduler) | [ğŸ”— Java](#task-scheduler) |
| 69  | Design Twitter | [ğŸ”— C++](#design-twitter) | [ğŸ”— Java](#design-twitter) |
| 70  | Find Median From Data Stream | [ğŸ”— C++](#find-median-from-data-stream) | [ğŸ”— Java](#find-median-from-data-stream) |
| 71  | Subsets | [ğŸ”— C++](#subsets) | [ğŸ”— Java](#subsets) |
| 72  | Combination Sum | [ğŸ”— C++](#combination-sum) | [ğŸ”— Java](#combination-sum) |
| 73  | Permutations | [ğŸ”— C++](#permutations) | [ğŸ”— Java](#permutations) |
| 74  | Subsets II | [ğŸ”— C++](#subsets-ii) | [ğŸ”— Java](#subsets-ii) |
| 75  | Combination Sum II | [ğŸ”— C++](#combination-sum-ii) | [ğŸ”— Java](#combination-sum-ii) |
| 76  | Word Search | [ğŸ”— C++](#word-search) | [ğŸ”— Java](#word-search) |
| 77  | Palindrome Partitioning | [ğŸ”— C++](#palindrome-partitioning) | [ğŸ”— Java](#palindrome-partitioning) |
| 78  | Letter Combinations of a Phone Number | [ğŸ”— C++](#letter-combinations-of-a-phone-number) | [ğŸ”— Java](#letter-combinations-of-a-phone-number) |
| 79  | N Queens | [ğŸ”— C++](#n-queens) | [ğŸ”— Java](#n-queens) |
| 80  | Number of Islands | [ğŸ”— C++](#number-of-islands) | [ğŸ”— Java](#number-of-islands) |
| 81  | Clone Graph | [ğŸ”— C++](#clone-graph) | [ğŸ”— Java](#clone-graph) |
| 82  | Max Area of Island | [ğŸ”— C++](#max-area-of-island) | [ğŸ”— Java](#max-area-of-island) |
| 83  | Pacific Atlantic Water Flow | [ğŸ”— C++](#pacific-atlantic-water-flow) | [ğŸ”— Java](#pacific-atlantic-water-flow) |
| 84  | Surrounded Regions | [ğŸ”— C++](#surrounded-regions) | [ğŸ”— Java](#surrounded-regions) |
| 85  | Rotting Oranges | [ğŸ”— C++](#rotting-oranges) | [ğŸ”— Java](#rotting-oranges) |
| 86  | Walls And Gates | [ğŸ”— C++](#walls-and-gates) | [ğŸ”— Java](#walls-and-gates) |
| 87  | Course Schedule | [ğŸ”— C++](#course-schedule) | [ğŸ”— Java](#course-schedule) |
| 88  | Course Schedule II | [ğŸ”— C++](#course-schedule-ii) | [ğŸ”— Java](#course-schedule-ii) |
| 89  | Redundant Connection | [ğŸ”— C++](#redundant-connection) | [ğŸ”— Java](#redundant-connection) |
| 90  | Number of Connected Components In An Undirected Graph | [ğŸ”— C++](#number-of-connected-components-in-an-undirected-graph) | [ğŸ”— Java](#number-of-connected-components-in-an-undirected-graph) |
| 91  | Graph Valid Tree | [ğŸ”— C++](#graph-valid-tree) | [ğŸ”— Java](#graph-valid-tree) |
| 92  | Word Ladder | [ğŸ”— C++](#word-ladder) | [ğŸ”— Java](#word-ladder) |
| 93  | Reconstruct Itinerary | [ğŸ”— C++](#reconstruct-itinerary) | [ğŸ”— Java](#reconstruct-itinerary) |
| 94  | Min Cost to Connect All Points | [ğŸ”— C++](#min-cost-to-connect-all-points) | [ğŸ”— Java](#min-cost-to-connect-all-points) |
| 95  | Network Delay Time | [ğŸ”— C++](#network-delay-time) | [ğŸ”— Java](#network-delay-time) |
| 96  | Swim In Rising Water | [ğŸ”— C++](#swim-in-rising-water) | [ğŸ”— Java](#swim-in-rising-water) |
| 97  | Alien Dictionary | [ğŸ”— C++](#alien-dictionary) | [ğŸ”— Java](#alien-dictionary) |
| 98  | Cheapest Flights Within K Stops | [ğŸ”— C++](#cheapest-flights-within-k-stops) | [ğŸ”— Java](#cheapest-flights-within-k-stops) |
| 99  | Climbing Stairs | [ğŸ”— C++](#climbing-stairs) | [ğŸ”— Java](#climbing-stairs) |
| 100 | Min Cost Climbing Stairs | [ğŸ”— C++](#min-cost-climbing-stairs) | [ğŸ”— Java](#min-cost-climbing-stairs) |
| 101 | House Robber | [ğŸ”— C++](#house-robber) | [ğŸ”— Java](#house-robber) |
| 102 | House Robber II | [ğŸ”— C++](#house-robber-ii) | [ğŸ”— Java](#house-robber-ii) |
| 103 | Longest Palindromic Substring | [ğŸ”— C++](#longest-palindromic-substring) | [ğŸ”— Java](#longest-palindromic-substring) |
| 104 | Palindromic Substrings | [ğŸ”— C++](#palindromic-substrings) | [ğŸ”— Java](#palindromic-substrings) |
| 105 | Decode Ways | [ğŸ”— C++](#decode-ways) | [ğŸ”— Java](#decode-ways) |
| 106 | Coin Change | [ğŸ”— C++](#coin-change) | [ğŸ”— Java](#coin-change) |
| 107 | Maximum Product Subarray | [ğŸ”— C++](#maximum-product-subarray) | [ğŸ”— Java](#maximum-product-subarray) |
| 108 | Word Break | [ğŸ”— C++](#word-break) | [ğŸ”— Java](#word-break) |
| 109 | Longest Increasing Subsequence | [ğŸ”— C++](#longest-increasing-subsequence) | [ğŸ”— Java](#longest-increasing-subsequence) |
| 110 | Partition Equal Subset Sum | [ğŸ”— C++](#partition-equal-subset-sum) | [ğŸ”— Java](#partition-equal-subset-sum) |
| 111 | Unique Paths | [ğŸ”— C++](#unique-paths) | [ğŸ”— Java](#unique-paths) |
| 112 | Longest Common Subsequence | [ğŸ”— C++](#longest-common-subsequence) | [ğŸ”— Java](#longest-common-subsequence) |
| 113 | Best Time to Buy And Sell Stock With Cooldown | [ğŸ”— C++](#best-time-to-buy-and-sell-stock-with-cooldown) | [ğŸ”— Java](#best-time-to-buy-and-sell-stock-with-cooldown) |
| 114 | Coin Change II | [ğŸ”— C++](#coin-change-ii) | [ğŸ”— Java](#coin-change-ii) |
| 115 | Target Sum | [ğŸ”— C++](#target-sum) | [ğŸ”— Java](#target-sum) |
| 116 | Interleaving String | [ğŸ”— C++](#interleaving-string) | [ğŸ”— Java](#interleaving-string) |
| 117 | Longest Increasing Path In a Matrix | [ğŸ”— C++](#longest-increasing-path-in-a-matrix) | [ğŸ”— Java](#longest-increasing-path-in-a-matrix) |
| 118 | Distinct Subsequences | [ğŸ”— C++](#distinct-subsequences) | [ğŸ”— Java](#distinct-subsequences) |
| 119 | Edit Distance | [ğŸ”— C++](#edit-distance) | [ğŸ”— Java](#edit-distance) |
| 120 | Burst Balloons | [ğŸ”— C++](#burst-balloons) | [ğŸ”— Java](#burst-balloons) |
| 121 | Regular Expression Matching | [ğŸ”— C++](#regular-expression-matching) | [ğŸ”— Java](#regular-expression-matching) |
| 122 | Maximum Subarray | [ğŸ”— C++](#maximum-subarray) | [ğŸ”— Java](#maximum-subarray) |
| 123 | Jump Game | [ğŸ”— C++](#jump-game) | [ğŸ”— Java](#jump-game) |
| 124 | Jump Game II | [ğŸ”— C++](#jump-game-ii) | [ğŸ”— Java](#jump-game-ii) |
| 125 | Gas Station | [ğŸ”— C++](#gas-station) | [ğŸ”— Java](#gas-station) |
| 126 | Hand of Straights | [ğŸ”— C++](#hand-of-straights) | [ğŸ”— Java](#hand-of-straights) |
| 127 | Merge Triplets to Form Target Triplet | [ğŸ”— C++](#merge-triplets-to-form-target-triplet) | [ğŸ”— Java](#merge-triplets-to-form-target-triplet) |
| 128 | Partition Labels | [ğŸ”— C++](#partition-labels) | [ğŸ”— Java](#partition-labels) |
| 129 | Valid Parenthesis String | [ğŸ”— C++](#valid-parenthesis-string) | [ğŸ”— Java](#valid-parenthesis-string) |
| 130 | Insert Interval | [ğŸ”— C++](#insert-interval) | [ğŸ”— Java](#insert-interval) |
| 131 | Merge Intervals | [ğŸ”— C++](#merge-intervals) | [ğŸ”— Java](#merge-intervals) |
| 132 | Non Overlapping Intervals | [ğŸ”— C++](#non-overlapping-intervals) | [ğŸ”— Java](#non-overlapping-intervals) |
| 133 | Meeting Rooms | [ğŸ”— C++](#meeting-rooms) | [ğŸ”— Java](#meeting-rooms) |
| 134 | Meeting Rooms II | [ğŸ”— C++](#meeting-rooms-ii) | [ğŸ”— Java](#meeting-rooms-ii) |
| 135 | Minimum Interval to Include Each Query | [ğŸ”— C++](#minimum-interval-to-include-each-query) | [ğŸ”— Java](#minimum-interval-to-include-each-query) |
| 136 | Rotate Image | [ğŸ”— C++](#rotate-image) | [ğŸ”— Java](#rotate-image) |
| 137 | Spiral Matrix | [ğŸ”— C++](#spiral-matrix) | [ğŸ”— Java](#spiral-matrix) |
| 138 | Set Matrix Zeroes | [ğŸ”— C++](#set-matrix-zeroes) | [ğŸ”— Java](#set-matrix-zeroes) |
| 139 | Happy Number | [ğŸ”— C++](#happy-number) | [ğŸ”— Java](#happy-number) |
| 140 | Plus One | [ğŸ”— C++](#plus-one) | [ğŸ”— Java](#plus-one) |
| 141 | Pow(x, n) | [ğŸ”— C++](#powx-n) | [ğŸ”— Java](#powx-n) |
| 142 | Multiply Strings | [ğŸ”— C++](#multiply-strings) | [ğŸ”— Java](#multiply-strings) |
| 143 | Detect Squares | [ğŸ”— C++](#detect-squares) | [ğŸ”— Java](#detect-squares) |
| 144 | Single Number | [ğŸ”— C++](#single-number) | [ğŸ”— Java](#single-number) |
| 145 | Number of 1 Bits | [ğŸ”— C++](#number-of-1-bits) | [ğŸ”— Java](#number-of-1-bits) |
| 146 | Counting Bits | [ğŸ”— C++](#counting-bits) | [ğŸ”— Java](#counting-bits) |
| 147 | Reverse Bits | [ğŸ”— C++](#reverse-bits) | [ğŸ”— Java](#reverse-bits) |
| 148 | Missing Number | [ğŸ”— C++](#missing-number) | [ğŸ”— Java](#missing-number) |
| 149 | Sum of Two Integers | [ğŸ”— C++](#sum-of-two-integers) | [ğŸ”— Java](#sum-of-two-integers) |
| 150 | Reverse Integer | [ğŸ”— C++](#reverse-integer) | [ğŸ”— Java](#reverse-integer) |


---

## ğŸ§  Contains Duplicate <a name="contains-duplicate"></a>

### ğŸ§¾ C++ Solution
```cpp
#include <unordered_set>
bool containsDuplicate(vector<int>& nums) {
    unordered_set<int> seen;
    for (int num : nums) {
        if (seen.count(num)) return true;
        seen.insert(num);
    }
    return false;
}
```

### â˜• Java Solution
```java
public boolean containsDuplicate(int[] nums) {
    Set<Integer> seen = new HashSet<>();
    for (int num : nums) {
        if (!seen.add(num)) return true;
    }
    return false;
}
```

---

## ğŸ§  Valid Anagram <a name="valid-anagram"></a>

### ğŸ§¾ C++ Solution
```cpp
bool isAnagram(string s, string t) {
    if (s.length() != t.length()) return false;
    vector<int> count(26, 0);
    for (int i = 0; i < s.length(); ++i) {
        count[s[i] - 'a']++;
        count[t[i] - 'a']--;
    }
    for (int c : count) {
        if (c != 0) return false;
    }
    return true;
}
```

### â˜• Java Solution
```java
public boolean isAnagram(String s, String t) {
    if (s.length() != t.length()) return false;
    int[] count = new int[26];
    for (int i = 0; i < s.length(); i++) {
        count[s.charAt(i) - 'a']++;
        count[t.charAt(i) - 'a']--;
    }
    for (int c : count) {
        if (c != 0) return false;
    }
    return true;
}
```

---

## ğŸ§  Two Sum <a name="two-sum"></a>

### ğŸ§¾ C++ Solution
```cpp
vector<int> twoSum(vector<int>& nums, int target) {
    unordered_map<int, int> m;
    for (int i = 0; i < nums.size(); ++i) {
        int complement = target - nums[i];
        if (m.count(complement)) return {m[complement], i};
        m[nums[i]] = i;
    }
    return {};
}
```

### â˜• Java Solution
```java
public int[] twoSum(int[] nums, int target) {
    Map<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        int complement = target - nums[i];
        if (map.containsKey(complement)) {
            return new int[] { map.get(complement), i };
        }
        map.put(nums[i], i);
    }
    return new int[] {};
}
```

---

## ğŸ§  Group Anagrams <a name="group-anagrams"></a>

### ğŸ§¾ C++ Solution
```cpp
vector<vector<string>> groupAnagrams(vector<string>& strs) {
    unordered_map<string, vector<string>> m;
    for (string s : strs) {
        string t = s;
        sort(t.begin(), t.end());
        m[t].push_back(s);
    }
    vector<vector<string>> res;
    for (auto it : m) res.push_back(it.second);
    return res;
}
```

### â˜• Java Solution
```java
public List<List<String>> groupAnagrams(String[] strs) {
    Map<String, List<String>> map = new HashMap<>();
    for (String s : strs) {
        char[] ca = s.toCharArray();
        Arrays.sort(ca);
        String key = new String(ca);
        map.computeIfAbsent(key, k -> new ArrayList<>()).add(s);
    }
    return new ArrayList<>(map.values());
}
```

---

## ğŸ§  Top K Frequent Elements <a name="top-k-frequent-elements"></a>

### ğŸ§¾ C++ Solution
```cpp
vector<int> topKFrequent(vector<int>& nums, int k) {
    unordered_map<int, int> count;
    for (int n : nums) count[n]++;
    priority_queue<pair<int, int>> heap;
    for (auto& p : count) heap.push({p.second, p.first});
    vector<int> res;
    while (k--) {
        res.push_back(heap.top().second);
        heap.pop();
    }
    return res;
}
```

### â˜• Java Solution
```java
public int[] topKFrequent(int[] nums, int k) {
    Map<Integer, Integer> count = new HashMap<>();
    for (int num : nums) count.put(num, count.getOrDefault(num, 0) + 1);
    PriorityQueue<Integer> heap = new PriorityQueue<>((a, b) -> count.get(b) - count.get(a));
    heap.addAll(count.keySet());
    int[] res = new int[k];
    for (int i = 0; i < k; i++) res[i] = heap.poll();
    return res;
}
```
---

## ğŸ§  Product of Array Except Self <a name="product-of-array-except-self"></a>

### ğŸ§¾ C++ Solution
```cpp
vector<int> productExceptSelf(vector<int>& nums) {
    int n = nums.size();
    vector<int> res(n, 1);
    int left = 1;
    for (int i = 0; i < n; ++i) {
        res[i] = left;
        left *= nums[i];
    }
    int right = 1;
    for (int i = n - 1; i >= 0; --i) {
        res[i] *= right;
        right *= nums[i];
    }
    return res;
}
```

### â˜• Java Solution
```java
public int[] productExceptSelf(int[] nums) {
    int n = nums.length;
    int[] res = new int[n];
    Arrays.fill(res, 1);
    int left = 1;
    for (int i = 0; i < n; i++) {
        res[i] = left;
        left *= nums[i];
    }
    int right = 1;
    for (int i = n - 1; i >= 0; i--) {
        res[i] *= right;
        right *= nums[i];
    }
    return res;
}
```

---

## ğŸ§  Valid Sudoku <a name="valid-sudoku"></a>

### ğŸ§¾ C++ Solution
```cpp
bool isValidSudoku(vector<vector<char>>& board) {
    unordered_set<string> seen;
    for (int i = 0; i < 9; ++i)
        for (int j = 0; j < 9; ++j) {
            char num = board[i][j];
            if (num == '.') continue;
            string row = to_string(num) + " in row " + to_string(i);
            string col = to_string(num) + " in col " + to_string(j);
            string box = to_string(num) + " in box " + to_string(i / 3) + "-" + to_string(j / 3);
            if (!seen.insert(row).second || !seen.insert(col).second || !seen.insert(box).second)
                return false;
        }
    return true;
}
```

### â˜• Java Solution
```java
public boolean isValidSudoku(char[][] board) {
    Set<String> seen = new HashSet<>();
    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            char num = board[i][j];
            if (num == '.') continue;
            String row = num + " in row " + i;
            String col = num + " in col " + j;
            String box = num + " in box " + i/3 + "-" + j/3;
            if (!seen.add(row) || !seen.add(col) || !seen.add(box))
                return false;
        }
    }
    return true;
}
```

---

## ğŸ§  Encode and Decode Strings <a name="encode-and-decode-strings"></a>

### ğŸ§¾ C++ Solution
```cpp
string encode(vector<string>& strs) {
    string res;
    for (string s : strs) res += to_string(s.length()) + "#" + s;
    return res;
}
vector<string> decode(string s) {
    vector<string> res;
    int i = 0;
    while (i < s.size()) {
        int j = i;
        while (s[j] != '#') j++;
        int len = stoi(s.substr(i, j - i));
        res.push_back(s.substr(j + 1, len));
        i = j + 1 + len;
    }
    return res;
}
```

### â˜• Java Solution
```java
public String encode(List<String> strs) {
    StringBuilder sb = new StringBuilder();
    for (String s : strs)
        sb.append(s.length()).append("#").append(s);
    return sb.toString();
}
public List<String> decode(String s) {
    List<String> res = new ArrayList<>();
    int i = 0;
    while (i < s.length()) {
        int j = i;
        while (s.charAt(j) != '#') j++;
        int len = Integer.parseInt(s.substring(i, j));
        res.add(s.substring(j + 1, j + 1 + len));
        i = j + 1 + len;
    }
    return res;
}
```

---

## ğŸ§  Longest Consecutive Sequence <a name="longest-consecutive-sequence"></a>

### ğŸ§¾ C++ Solution
```cpp
int longestConsecutive(vector<int>& nums) {
    unordered_set<int> num_set(nums.begin(), nums.end());
    int longest = 0;
    for (int num : num_set) {
        if (!num_set.count(num - 1)) {
            int curr = num;
            int streak = 1;
            while (num_set.count(curr + 1)) {
                curr++;
                streak++;
            }
            longest = max(longest, streak);
        }
    }
    return longest;
}
```

### â˜• Java Solution
```java
public int longestConsecutive(int[] nums) {
    Set<Integer> set = new HashSet<>();
    for (int num : nums) set.add(num);
    int longest = 0;
    for (int num : set) {
        if (!set.contains(num - 1)) {
            int curr = num;
            int streak = 1;
            while (set.contains(curr + 1)) {
                curr++;
                streak++;
            }
            longest = Math.max(longest, streak);
        }
    }
    return longest;
}
```

---

## ğŸ§  Valid Palindrome <a name="valid-palindrome"></a>

### ğŸ§¾ C++ Solution
```cpp
bool isPalindrome(string s) {
    int l = 0, r = s.size() - 1;
    while (l < r) {
        while (l < r && !isalnum(s[l])) l++;
        while (l < r && !isalnum(s[r])) r--;
        if (tolower(s[l++]) != tolower(s[r--])) return false;
    }
    return true;
}
```

### â˜• Java Solution
```java
public boolean isPalindrome(String s) {
    int l = 0, r = s.length() - 1;
    while (l < r) {
        while (l < r && !Character.isLetterOrDigit(s.charAt(l))) l++;
        while (l < r && !Character.isLetterOrDigit(s.charAt(r))) r--;
        if (Character.toLowerCase(s.charAt(l++)) != Character.toLowerCase(s.charAt(r--)))
            return false;
    }
    return true;
}
```



 Made with â¤ï¸ by Tushar Kashyap
