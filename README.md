# 📘 LeetCode Solutions in C++ and Java

Welcome to our collaborative LeetCode solutions repository! This project contains **150 curated coding problems** with solutions implemented in both **C++** and **Java**.

### 👥 Contributors:
- **Vedika** – All solutions in **C++**
- **Tushar Kashyap** – All solutions in **Java**
---

## 📑 Problem Index


| No. | Question Name | C++ | Java |
|-----|---------------|-----|------|
| 1   | Contains Duplicate | [🔗 C++](#contains-duplicate) | [🔗 Java](#contains-duplicate) |
| 2   | Valid Anagram | [🔗 C++](#valid-anagram) | [🔗 Java](#valid-anagram) |
| 3   | Two Sum | [🔗 C++](#two-sum) | [🔗 Java](#two-sum) |
| 4   | Group Anagrams | [🔗 C++](#group-anagrams) | [🔗 Java](#group-anagrams) |
| 5   | Top K Frequent Elements | [🔗 C++](#top-k-frequent-elements) | [🔗 Java](#top-k-frequent-elements) |
| 6   | Product of Array Except Self | [🔗 C++](#product-of-array-except-self) | [🔗 Java](#product-of-array-except-self) |
| 7   | Valid Sudoku | [🔗 C++](#valid-sudoku) | [🔗 Java](#valid-sudoku) |
| 8   | Encode and Decode Strings | [🔗 C++](#encode-and-decode-strings) | [🔗 Java](#encode-and-decode-strings) |
| 9   | Longest Consecutive Sequence | [🔗 C++](#longest-consecutive-sequence) | [🔗 Java](#longest-consecutive-sequence) |
| 10  | Valid Palindrome | [🔗 C++](#valid-palindrome) | [🔗 Java](#valid-palindrome) |
| 11  | Two Sum II Input Array Is Sorted | [🔗 C++](#two-sum-ii-input-array-is-sorted) | [🔗 Java](#two-sum-ii-input-array-is-sorted) |
| 12  | 3Sum | [🔗 C++](#3sum) | [🔗 Java](#3sum) |
| 13  | Container With Most Water | [🔗 C++](#container-with-most-water) | [🔗 Java](#container-with-most-water) |
| 14  | Trapping Rain Water | [🔗 C++](#trapping-rain-water) | [🔗 Java](#trapping-rain-water) |
| 15  | Best Time to Buy And Sell Stock | [🔗 C++](#best-time-to-buy-and-sell-stock) | [🔗 Java](#best-time-to-buy-and-sell-stock) |
| 16  | Longest Substring Without Repeating Characters | [🔗 C++](#longest-substring-without-repeating-characters) | [🔗 Java](#longest-substring-without-repeating-characters) |
| 17  | Longest Repeating Character Replacement | [🔗 C++](#longest-repeating-character-replacement) | [🔗 Java](#longest-repeating-character-replacement) |
| 18  | Permutation In String | [🔗 C++](#permutation-in-string) | [🔗 Java](#permutation-in-string) |
| 19  | Minimum Window Substring | [🔗 C++](#minimum-window-substring) | [🔗 Java](#minimum-window-substring) |
| 20  | Sliding Window Maximum | [🔗 C++](#sliding-window-maximum) | [🔗 Java](#sliding-window-maximum) |
| 21  | Valid Parentheses | [🔗 C++](#valid-parentheses) | [🔗 Java](#valid-parentheses) |
| 22  | Min Stack | [🔗 C++](#min-stack) | [🔗 Java](#min-stack) |
| 23  | Evaluate Reverse Polish Notation | [🔗 C++](#evaluate-reverse-polish-notation) | [🔗 Java](#evaluate-reverse-polish-notation) |
| 24  | Generate Parentheses | [🔗 C++](#generate-parentheses) | [🔗 Java](#generate-parentheses) |
| 25  | Daily Temperatures | [🔗 C++](#daily-temperatures) | [🔗 Java](#daily-temperatures) |
| 26  | Car Fleet | [🔗 C++](#car-fleet) | [🔗 Java](#car-fleet) |
| 27  | Largest Rectangle In Histogram | [🔗 C++](#largest-rectangle-in-histogram) | [🔗 Java](#largest-rectangle-in-histogram) |
| 28  | Binary Search | [🔗 C++](#binary-search) | [🔗 Java](#binary-search) |
| 29  | Search a 2D Matrix | [🔗 C++](#search-a-2d-matrix) | [🔗 Java](#search-a-2d-matrix) |
| 30  | Koko Eating Bananas | [🔗 C++](#koko-eating-bananas) | [🔗 Java](#koko-eating-bananas) |
| 31  | Find Minimum In Rotated Sorted Array | [🔗 C++](#find-minimum-in-rotated-sorted-array) | [🔗 Java](#find-minimum-in-rotated-sorted-array) |
| 32  | Search In Rotated Sorted Array | [🔗 C++](#search-in-rotated-sorted-array) | [🔗 Java](#search-in-rotated-sorted-array) |
| 33  | Time Based Key Value Store | [🔗 C++](#time-based-key-value-store) | [🔗 Java](#time-based-key-value-store) |
| 34  | Median of Two Sorted Arrays | [🔗 C++](#median-of-two-sorted-arrays) | [🔗 Java](#median-of-two-sorted-arrays) |
| 35  | Reverse Linked List | [🔗 C++](#reverse-linked-list) | [🔗 Java](#reverse-linked-list) |
| 36  | Merge Two Sorted Lists | [🔗 C++](#merge-two-sorted-lists) | [🔗 Java](#merge-two-sorted-lists) |
| 37  | Reorder List | [🔗 C++](#reorder-list) | [🔗 Java](#reorder-list) |
| 38  | Remove Nth Node From End of List | [🔗 C++](#remove-nth-node-from-end-of-list) | [🔗 Java](#remove-nth-node-from-end-of-list) |
| 39  | Copy List With Random Pointer | [🔗 C++](#copy-list-with-random-pointer) | [🔗 Java](#copy-list-with-random-pointer) |
| 40  | Add Two Numbers | [🔗 C++](#add-two-numbers) | [🔗 Java](#add-two-numbers) |
| 41  | Linked List Cycle | [🔗 C++](#linked-list-cycle) | [🔗 Java](#linked-list-cycle) |
| 42  | Find The Duplicate Number | [🔗 C++](#find-the-duplicate-number) | [🔗 Java](#find-the-duplicate-number) |
| 43  | LRU Cache | [🔗 C++](#lru-cache) | [🔗 Java](#lru-cache) |
| 44  | Merge K Sorted Lists | [🔗 C++](#merge-k-sorted-lists) | [🔗 Java](#merge-k-sorted-lists) |
| 45  | Reverse Nodes In K Group | [🔗 C++](#reverse-nodes-in-k-group) | [🔗 Java](#reverse-nodes-in-k-group) |
| 46  | Invert Binary Tree | [🔗 C++](#invert-binary-tree) | [🔗 Java](#invert-binary-tree) |
| 47  | Maximum Depth of Binary Tree | [🔗 C++](#maximum-depth-of-binary-tree) | [🔗 Java](#maximum-depth-of-binary-tree) |
| 48  | Diameter of Binary Tree | [🔗 C++](#diameter-of-binary-tree) | [🔗 Java](#diameter-of-binary-tree) |
| 49  | Balanced Binary Tree | [🔗 C++](#balanced-binary-tree) | [🔗 Java](#balanced-binary-tree) |
| 50  | Same Tree | [🔗 C++](#same-tree) | [🔗 Java](#same-tree) |
| 51  | Subtree of Another Tree | [🔗 C++](#subtree-of-another-tree) | [🔗 Java](#subtree-of-another-tree) |
| 52  | Lowest Common Ancestor of a Binary Search Tree | [🔗 C++](#lowest-common-ancestor-of-a-binary-search-tree) | [🔗 Java](#lowest-common-ancestor-of-a-binary-search-tree) |
| 53  | Binary Tree Level Order Traversal | [🔗 C++](#binary-tree-level-order-traversal) | [🔗 Java](#binary-tree-level-order-traversal) |
| 54  | Binary Tree Right Side View | [🔗 C++](#binary-tree-right-side-view) | [🔗 Java](#binary-tree-right-side-view) |
| 55  | Count Good Nodes In Binary Tree | [🔗 C++](#count-good-nodes-in-binary-tree) | [🔗 Java](#count-good-nodes-in-binary-tree) |
| 56  | Validate Binary Search Tree | [🔗 C++](#validate-binary-search-tree) | [🔗 Java](#validate-binary-search-tree) |
| 57  | Kth Smallest Element In a Bst | [🔗 C++](#kth-smallest-element-in-a-bst) | [🔗 Java](#kth-smallest-element-in-a-bst) |
| 58  | Construct Binary Tree From Preorder And Inorder Traversal | [🔗 C++](#construct-binary-tree-from-preorder-and-inorder-traversal) | [🔗 Java](#construct-binary-tree-from-preorder-and-inorder-traversal) |
| 59  | Binary Tree Maximum Path Sum | [🔗 C++](#binary-tree-maximum-path-sum) | [🔗 Java](#binary-tree-maximum-path-sum) |
| 60  | Serialize And Deserialize Binary Tree | [🔗 C++](#serialize-and-deserialize-binary-tree) | [🔗 Java](#serialize-and-deserialize-binary-tree) |
| 61  | Implement Trie Prefix Tree | [🔗 C++](#implement-trie-prefix-tree) | [🔗 Java](#implement-trie-prefix-tree) |
| 62  | Design Add And Search Words Data Structure | [🔗 C++](#design-add-and-search-words-data-structure) | [🔗 Java](#design-add-and-search-words-data-structure) |
| 63  | Word Search II | [🔗 C++](#word-search-ii) | [🔗 Java](#word-search-ii) |
| 64  | Kth Largest Element In a Stream | [🔗 C++](#kth-largest-element-in-a-stream) | [🔗 Java](#kth-largest-element-in-a-stream) |
| 65  | Last Stone Weight | [🔗 C++](#last-stone-weight) | [🔗 Java](#last-stone-weight) |
| 66  | K Closest Points to Origin | [🔗 C++](#k-closest-points-to-origin) | [🔗 Java](#k-closest-points-to-origin) |
| 67  | Kth Largest Element In An Array | [🔗 C++](#kth-largest-element-in-an-array) | [🔗 Java](#kth-largest-element-in-an-array) |
| 68  | Task Scheduler | [🔗 C++](#task-scheduler) | [🔗 Java](#task-scheduler) |
| 69  | Design Twitter | [🔗 C++](#design-twitter) | [🔗 Java](#design-twitter) |
| 70  | Find Median From Data Stream | [🔗 C++](#find-median-from-data-stream) | [🔗 Java](#find-median-from-data-stream) |
| 71  | Subsets | [🔗 C++](#subsets) | [🔗 Java](#subsets) |
| 72  | Combination Sum | [🔗 C++](#combination-sum) | [🔗 Java](#combination-sum) |
| 73  | Permutations | [🔗 C++](#permutations) | [🔗 Java](#permutations) |
| 74  | Subsets II | [🔗 C++](#subsets-ii) | [🔗 Java](#subsets-ii) |
| 75  | Combination Sum II | [🔗 C++](#combination-sum-ii) | [🔗 Java](#combination-sum-ii) |
| 76  | Word Search | [🔗 C++](#word-search) | [🔗 Java](#word-search) |
| 77  | Palindrome Partitioning | [🔗 C++](#palindrome-partitioning) | [🔗 Java](#palindrome-partitioning) |
| 78  | Letter Combinations of a Phone Number | [🔗 C++](#letter-combinations-of-a-phone-number) | [🔗 Java](#letter-combinations-of-a-phone-number) |
| 79  | N Queens | [🔗 C++](#n-queens) | [🔗 Java](#n-queens) |
| 80  | Number of Islands | [🔗 C++](#number-of-islands) | [🔗 Java](#number-of-islands) |
| 81  | Clone Graph | [🔗 C++](#clone-graph) | [🔗 Java](#clone-graph) |
| 82  | Max Area of Island | [🔗 C++](#max-area-of-island) | [🔗 Java](#max-area-of-island) |
| 83  | Pacific Atlantic Water Flow | [🔗 C++](#pacific-atlantic-water-flow) | [🔗 Java](#pacific-atlantic-water-flow) |
| 84  | Surrounded Regions | [🔗 C++](#surrounded-regions) | [🔗 Java](#surrounded-regions) |
| 85  | Rotting Oranges | [🔗 C++](#rotting-oranges) | [🔗 Java](#rotting-oranges) |
| 86  | Walls And Gates | [🔗 C++](#walls-and-gates) | [🔗 Java](#walls-and-gates) |
| 87  | Course Schedule | [🔗 C++](#course-schedule) | [🔗 Java](#course-schedule) |
| 88  | Course Schedule II | [🔗 C++](#course-schedule-ii) | [🔗 Java](#course-schedule-ii) |
| 89  | Redundant Connection | [🔗 C++](#redundant-connection) | [🔗 Java](#redundant-connection) |
| 90  | Number of Connected Components In An Undirected Graph | [🔗 C++](#number-of-connected-components-in-an-undirected-graph) | [🔗 Java](#number-of-connected-components-in-an-undirected-graph) |
| 91  | Graph Valid Tree | [🔗 C++](#graph-valid-tree) | [🔗 Java](#graph-valid-tree) |
| 92  | Word Ladder | [🔗 C++](#word-ladder) | [🔗 Java](#word-ladder) |
| 93  | Reconstruct Itinerary | [🔗 C++](#reconstruct-itinerary) | [🔗 Java](#reconstruct-itinerary) |
| 94  | Min Cost to Connect All Points | [🔗 C++](#min-cost-to-connect-all-points) | [🔗 Java](#min-cost-to-connect-all-points) |
| 95  | Network Delay Time | [🔗 C++](#network-delay-time) | [🔗 Java](#network-delay-time) |
| 96  | Swim In Rising Water | [🔗 C++](#swim-in-rising-water) | [🔗 Java](#swim-in-rising-water) |
| 97  | Alien Dictionary | [🔗 C++](#alien-dictionary) | [🔗 Java](#alien-dictionary) |
| 98  | Cheapest Flights Within K Stops | [🔗 C++](#cheapest-flights-within-k-stops) | [🔗 Java](#cheapest-flights-within-k-stops) |
| 99  | Climbing Stairs | [🔗 C++](#climbing-stairs) | [🔗 Java](#climbing-stairs) |
| 100 | Min Cost Climbing Stairs | [🔗 C++](#min-cost-climbing-stairs) | [🔗 Java](#min-cost-climbing-stairs) |
| 101 | House Robber | [🔗 C++](#house-robber) | [🔗 Java](#house-robber) |
| 102 | House Robber II | [🔗 C++](#house-robber-ii) | [🔗 Java](#house-robber-ii) |
| 103 | Longest Palindromic Substring | [🔗 C++](#longest-palindromic-substring) | [🔗 Java](#longest-palindromic-substring) |
| 104 | Palindromic Substrings | [🔗 C++](#palindromic-substrings) | [🔗 Java](#palindromic-substrings) |
| 105 | Decode Ways | [🔗 C++](#decode-ways) | [🔗 Java](#decode-ways) |
| 106 | Coin Change | [🔗 C++](#coin-change) | [🔗 Java](#coin-change) |
| 107 | Maximum Product Subarray | [🔗 C++](#maximum-product-subarray) | [🔗 Java](#maximum-product-subarray) |
| 108 | Word Break | [🔗 C++](#word-break) | [🔗 Java](#word-break) |
| 109 | Longest Increasing Subsequence | [🔗 C++](#longest-increasing-subsequence) | [🔗 Java](#longest-increasing-subsequence) |
| 110 | Partition Equal Subset Sum | [🔗 C++](#partition-equal-subset-sum) | [🔗 Java](#partition-equal-subset-sum) |
| 111 | Unique Paths | [🔗 C++](#unique-paths) | [🔗 Java](#unique-paths) |
| 112 | Longest Common Subsequence | [🔗 C++](#longest-common-subsequence) | [🔗 Java](#longest-common-subsequence) |
| 113 | Best Time to Buy And Sell Stock With Cooldown | [🔗 C++](#best-time-to-buy-and-sell-stock-with-cooldown) | [🔗 Java](#best-time-to-buy-and-sell-stock-with-cooldown) |
| 114 | Coin Change II | [🔗 C++](#coin-change-ii) | [🔗 Java](#coin-change-ii) |
| 115 | Target Sum | [🔗 C++](#target-sum) | [🔗 Java](#target-sum) |
| 116 | Interleaving String | [🔗 C++](#interleaving-string) | [🔗 Java](#interleaving-string) |
| 117 | Longest Increasing Path In a Matrix | [🔗 C++](#longest-increasing-path-in-a-matrix) | [🔗 Java](#longest-increasing-path-in-a-matrix) |
| 118 | Distinct Subsequences | [🔗 C++](#distinct-subsequences) | [🔗 Java](#distinct-subsequences) |
| 119 | Edit Distance | [🔗 C++](#edit-distance) | [🔗 Java](#edit-distance) |
| 120 | Burst Balloons | [🔗 C++](#burst-balloons) | [🔗 Java](#burst-balloons) |
| 121 | Regular Expression Matching | [🔗 C++](#regular-expression-matching) | [🔗 Java](#regular-expression-matching) |
| 122 | Maximum Subarray | [🔗 C++](#maximum-subarray) | [🔗 Java](#maximum-subarray) |
| 123 | Jump Game | [🔗 C++](#jump-game) | [🔗 Java](#jump-game) |
| 124 | Jump Game II | [🔗 C++](#jump-game-ii) | [🔗 Java](#jump-game-ii) |
| 125 | Gas Station | [🔗 C++](#gas-station) | [🔗 Java](#gas-station) |
| 126 | Hand of Straights | [🔗 C++](#hand-of-straights) | [🔗 Java](#hand-of-straights) |
| 127 | Merge Triplets to Form Target Triplet | [🔗 C++](#merge-triplets-to-form-target-triplet) | [🔗 Java](#merge-triplets-to-form-target-triplet) |
| 128 | Partition Labels | [🔗 C++](#partition-labels) | [🔗 Java](#partition-labels) |
| 129 | Valid Parenthesis String | [🔗 C++](#valid-parenthesis-string) | [🔗 Java](#valid-parenthesis-string) |
| 130 | Insert Interval | [🔗 C++](#insert-interval) | [🔗 Java](#insert-interval) |
| 131 | Merge Intervals | [🔗 C++](#merge-intervals) | [🔗 Java](#merge-intervals) |
| 132 | Non Overlapping Intervals | [🔗 C++](#non-overlapping-intervals) | [🔗 Java](#non-overlapping-intervals) |
| 133 | Meeting Rooms | [🔗 C++](#meeting-rooms) | [🔗 Java](#meeting-rooms) |
| 134 | Meeting Rooms II | [🔗 C++](#meeting-rooms-ii) | [🔗 Java](#meeting-rooms-ii) |
| 135 | Minimum Interval to Include Each Query | [🔗 C++](#minimum-interval-to-include-each-query) | [🔗 Java](#minimum-interval-to-include-each-query) |
| 136 | Rotate Image | [🔗 C++](#rotate-image) | [🔗 Java](#rotate-image) |
| 137 | Spiral Matrix | [🔗 C++](#spiral-matrix) | [🔗 Java](#spiral-matrix) |
| 138 | Set Matrix Zeroes | [🔗 C++](#set-matrix-zeroes) | [🔗 Java](#set-matrix-zeroes) |
| 139 | Happy Number | [🔗 C++](#happy-number) | [🔗 Java](#happy-number) |
| 140 | Plus One | [🔗 C++](#plus-one) | [🔗 Java](#plus-one) |
| 141 | Pow(x, n) | [🔗 C++](#powx-n) | [🔗 Java](#powx-n) |
| 142 | Multiply Strings | [🔗 C++](#multiply-strings) | [🔗 Java](#multiply-strings) |
| 143 | Detect Squares | [🔗 C++](#detect-squares) | [🔗 Java](#detect-squares) |
| 144 | Single Number | [🔗 C++](#single-number) | [🔗 Java](#single-number) |
| 145 | Number of 1 Bits | [🔗 C++](#number-of-1-bits) | [🔗 Java](#number-of-1-bits) |
| 146 | Counting Bits | [🔗 C++](#counting-bits) | [🔗 Java](#counting-bits) |
| 147 | Reverse Bits | [🔗 C++](#reverse-bits) | [🔗 Java](#reverse-bits) |
| 148 | Missing Number | [🔗 C++](#missing-number) | [🔗 Java](#missing-number) |
| 149 | Sum of Two Integers | [🔗 C++](#sum-of-two-integers) | [🔗 Java](#sum-of-two-integers) |
| 150 | Reverse Integer | [🔗 C++](#reverse-integer) | [🔗 Java](#reverse-integer) |


---

## 🧠 Contains Duplicate <a name="contains-duplicate"></a>

### 🧾 C++ Solution
```cpp
#include <unordered_set>
bool containsDuplicate(vector<int>& nums) {
    unordered_set<int> seen;
    for (int num : nums) {
        if (seen.count(num)) return true;
        seen.insert(num);
    }
    return false;
}
```

### ☕ Java Solution
```java
public boolean containsDuplicate(int[] nums) {
    Set<Integer> seen = new HashSet<>();
    for (int num : nums) {
        if (!seen.add(num)) return true;
    }
    return false;
}
```

---

## 🧠 Valid Anagram <a name="valid-anagram"></a>

### 🧾 C++ Solution
```cpp
bool isAnagram(string s, string t) {
    if (s.length() != t.length()) return false;
    vector<int> count(26, 0);
    for (int i = 0; i < s.length(); ++i) {
        count[s[i] - 'a']++;
        count[t[i] - 'a']--;
    }
    for (int c : count) {
        if (c != 0) return false;
    }
    return true;
}
```

### ☕ Java Solution
```java
public boolean isAnagram(String s, String t) {
    if (s.length() != t.length()) return false;
    int[] count = new int[26];
    for (int i = 0; i < s.length(); i++) {
        count[s.charAt(i) - 'a']++;
        count[t.charAt(i) - 'a']--;
    }
    for (int c : count) {
        if (c != 0) return false;
    }
    return true;
}
```

---

## 🧠 Two Sum <a name="two-sum"></a>

### 🧾 C++ Solution
```cpp
vector<int> twoSum(vector<int>& nums, int target) {
    unordered_map<int, int> m;
    for (int i = 0; i < nums.size(); ++i) {
        int complement = target - nums[i];
        if (m.count(complement)) return {m[complement], i};
        m[nums[i]] = i;
    }
    return {};
}
```

### ☕ Java Solution
```java
public int[] twoSum(int[] nums, int target) {
    Map<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        int complement = target - nums[i];
        if (map.containsKey(complement)) {
            return new int[] { map.get(complement), i };
        }
        map.put(nums[i], i);
    }
    return new int[] {};
}
```

---

## 🧠 Group Anagrams <a name="group-anagrams"></a>

### 🧾 C++ Solution
```cpp
vector<vector<string>> groupAnagrams(vector<string>& strs) {
    unordered_map<string, vector<string>> m;
    for (string s : strs) {
        string t = s;
        sort(t.begin(), t.end());
        m[t].push_back(s);
    }
    vector<vector<string>> res;
    for (auto it : m) res.push_back(it.second);
    return res;
}
```

### ☕ Java Solution
```java
public List<List<String>> groupAnagrams(String[] strs) {
    Map<String, List<String>> map = new HashMap<>();
    for (String s : strs) {
        char[] ca = s.toCharArray();
        Arrays.sort(ca);
        String key = new String(ca);
        map.computeIfAbsent(key, k -> new ArrayList<>()).add(s);
    }
    return new ArrayList<>(map.values());
}
```

---

## 🧠 Top K Frequent Elements <a name="top-k-frequent-elements"></a>

### 🧾 C++ Solution
```cpp
vector<int> topKFrequent(vector<int>& nums, int k) {
    unordered_map<int, int> count;
    for (int n : nums) count[n]++;
    priority_queue<pair<int, int>> heap;
    for (auto& p : count) heap.push({p.second, p.first});
    vector<int> res;
    while (k--) {
        res.push_back(heap.top().second);
        heap.pop();
    }
    return res;
}
```

### ☕ Java Solution
```java
public int[] topKFrequent(int[] nums, int k) {
    Map<Integer, Integer> count = new HashMap<>();
    for (int num : nums) count.put(num, count.getOrDefault(num, 0) + 1);
    PriorityQueue<Integer> heap = new PriorityQueue<>((a, b) -> count.get(b) - count.get(a));
    heap.addAll(count.keySet());
    int[] res = new int[k];
    for (int i = 0; i < k; i++) res[i] = heap.poll();
    return res;
}
```
---

## 🧠 Product of Array Except Self <a name="product-of-array-except-self"></a>

### 🧾 C++ Solution
```cpp
vector<int> productExceptSelf(vector<int>& nums) {
    int n = nums.size();
    vector<int> res(n, 1);
    int left = 1;
    for (int i = 0; i < n; ++i) {
        res[i] = left;
        left *= nums[i];
    }
    int right = 1;
    for (int i = n - 1; i >= 0; --i) {
        res[i] *= right;
        right *= nums[i];
    }
    return res;
}
```

### ☕ Java Solution
```java
public int[] productExceptSelf(int[] nums) {
    int n = nums.length;
    int[] res = new int[n];
    Arrays.fill(res, 1);
    int left = 1;
    for (int i = 0; i < n; i++) {
        res[i] = left;
        left *= nums[i];
    }
    int right = 1;
    for (int i = n - 1; i >= 0; i--) {
        res[i] *= right;
        right *= nums[i];
    }
    return res;
}
```

---

## 🧠 Valid Sudoku <a name="valid-sudoku"></a>

### 🧾 C++ Solution
```cpp
bool isValidSudoku(vector<vector<char>>& board) {
    unordered_set<string> seen;
    for (int i = 0; i < 9; ++i)
        for (int j = 0; j < 9; ++j) {
            char num = board[i][j];
            if (num == '.') continue;
            string row = to_string(num) + " in row " + to_string(i);
            string col = to_string(num) + " in col " + to_string(j);
            string box = to_string(num) + " in box " + to_string(i / 3) + "-" + to_string(j / 3);
            if (!seen.insert(row).second || !seen.insert(col).second || !seen.insert(box).second)
                return false;
        }
    return true;
}
```

### ☕ Java Solution
```java
public boolean isValidSudoku(char[][] board) {
    Set<String> seen = new HashSet<>();
    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            char num = board[i][j];
            if (num == '.') continue;
            String row = num + " in row " + i;
            String col = num + " in col " + j;
            String box = num + " in box " + i/3 + "-" + j/3;
            if (!seen.add(row) || !seen.add(col) || !seen.add(box))
                return false;
        }
    }
    return true;
}
```

---

## 🧠 Encode and Decode Strings <a name="encode-and-decode-strings"></a>

### 🧾 C++ Solution
```cpp
string encode(vector<string>& strs) {
    string res;
    for (string s : strs) res += to_string(s.length()) + "#" + s;
    return res;
}
vector<string> decode(string s) {
    vector<string> res;
    int i = 0;
    while (i < s.size()) {
        int j = i;
        while (s[j] != '#') j++;
        int len = stoi(s.substr(i, j - i));
        res.push_back(s.substr(j + 1, len));
        i = j + 1 + len;
    }
    return res;
}
```

### ☕ Java Solution
```java
public String encode(List<String> strs) {
    StringBuilder sb = new StringBuilder();
    for (String s : strs)
        sb.append(s.length()).append("#").append(s);
    return sb.toString();
}
public List<String> decode(String s) {
    List<String> res = new ArrayList<>();
    int i = 0;
    while (i < s.length()) {
        int j = i;
        while (s.charAt(j) != '#') j++;
        int len = Integer.parseInt(s.substring(i, j));
        res.add(s.substring(j + 1, j + 1 + len));
        i = j + 1 + len;
    }
    return res;
}
```

---

## 🧠 Longest Consecutive Sequence <a name="longest-consecutive-sequence"></a>

### 🧾 C++ Solution
```cpp
int longestConsecutive(vector<int>& nums) {
    unordered_set<int> num_set(nums.begin(), nums.end());
    int longest = 0;
    for (int num : num_set) {
        if (!num_set.count(num - 1)) {
            int curr = num;
            int streak = 1;
            while (num_set.count(curr + 1)) {
                curr++;
                streak++;
            }
            longest = max(longest, streak);
        }
    }
    return longest;
}
```

### ☕ Java Solution
```java
public int longestConsecutive(int[] nums) {
    Set<Integer> set = new HashSet<>();
    for (int num : nums) set.add(num);
    int longest = 0;
    for (int num : set) {
        if (!set.contains(num - 1)) {
            int curr = num;
            int streak = 1;
            while (set.contains(curr + 1)) {
                curr++;
                streak++;
            }
            longest = Math.max(longest, streak);
        }
    }
    return longest;
}
```

---

## 🧠 Valid Palindrome <a name="valid-palindrome"></a>

### 🧾 C++ Solution
```cpp
bool isPalindrome(string s) {
    int l = 0, r = s.size() - 1;
    while (l < r) {
        while (l < r && !isalnum(s[l])) l++;
        while (l < r && !isalnum(s[r])) r--;
        if (tolower(s[l++]) != tolower(s[r--])) return false;
    }
    return true;
}
```

### ☕ Java Solution
```java
public boolean isPalindrome(String s) {
    int l = 0, r = s.length() - 1;
    while (l < r) {
        while (l < r && !Character.isLetterOrDigit(s.charAt(l))) l++;
        while (l < r && !Character.isLetterOrDigit(s.charAt(r))) r--;
        if (Character.toLowerCase(s.charAt(l++)) != Character.toLowerCase(s.charAt(r--)))
            return false;
    }
    return true;
}
```



 Made with ❤️ by Tushar Kashyap
